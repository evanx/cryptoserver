{"version":3,"sources":["../lib/Metas.js"],"names":[],"mappings":"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","file":"Metas.js","sourcesContent":["\nconst logger = Loggers.create(__filename, 'info');\n\nexport function isSpecType(meta, type) {\n   logger.debug('isSpecType', meta.spec, type);\n   return meta.spec.includes(type);\n}\n\nexport function pickEnv(meta, env) {\n   const result = {};\n   Object.keys(meta).filter(key => env.hasOwnProperty(key))\n   .forEach(key => result[key] = env[key]);\n   return result;\n}\n\nexport function getErrorKeys(meta, props) {\n   return Object.keys(meta).filter(key => !isValid(meta[key], key, props[key]));\n}\n\nfunction isValid(meta, key, value) {\n   logger.debug('isValid', key, value, meta);\n   if (value === undefined) {\n      return meta.optional;\n   } else if (meta.type === 'url') {\n      return typeof value === 'string' && value.match(/^http/);\n   } else if (meta.type === 'file') {\n      return typeof value === 'string' && Files.existsFile(value);\n   } else if (meta.type === 'string') {\n      return typeof value === 'string';\n   } else if (meta.type === 'duration') {\n      return parseInt(value) === value;\n   } else if (meta.type === 'integer') {\n      return parseInt(value) === value;\n   } else if (meta.type === 'boolean' || lodash.isBoolean(meta.defaultValue)) {\n      return lodash.isBoolean(value);\n   } else if (meta.type === 'object') {\n      return Object.keys(value).length;\n   } else if (lodash.isString(meta.defaultValue) && lodash.isString(value)) {\n      if (meta.regex) {\n         logger.debug('isValid', meta, value);\n         return new RegExp('^' + meta.regex + '$').test(value);\n      } else {\n         return true;\n      }\n   } else if (meta.defaultValue > 0 && value > 0) {\n      if (meta.regex) {\n         return new RegExp('^' + meta.regex + '$').test('' + value);\n      } else {\n         return true;\n      }\n      return true;\n   } else if (lodash.isArray(meta.defaultValue) && lodash.isArray(value)) {\n      return true;\n   } else {\n      return false;\n   }\n}\n\nexport function getDefault(meta) {\n   const result = {};\n   Object.keys(meta).filter(key => meta[key].defaultValue !== undefined)\n   .forEach(key => result[key] = meta[key].defaultValue);\n   return result;\n}\n\nexport function getEnv(meta, componentName, env) {\n   const result = {};\n   Object.keys(meta).filter(key => {\n      const envKey = [componentName, key].join('_');\n      return env.hasOwnProperty(envKey);\n   }).forEach(key => {\n      const envKey = [componentName, key].join('_');\n      result[key] = env[envKey];\n   });\n   logger.info('getEnv', componentName, Object.keys(result));\n   return result;\n}\n\n// TODO integration the following\n\n/*\nvar that = {\n   minTimestamp: 1459109145,\n   minInterval: 1,\n   maxInterval: 3600,\n   defaultProps: {},\n   validateProps: function(p) {\n      Asserts.assertIntegerMax(p.serviceRenew, 'serviceRenew', p.serviceExpire - 5);\n   },\n   start: function(props) {\n      Object.keys(props).forEach(function(key) {\n         props[key].key = key;\n         var defaultValue = props[key].defaultValue;\n         if (defaultValue) {\n            that.defaultProps[key] = defaultValue;\n         }\n      });\n      console.log('defaultProps', that.defaultProps);\n      that.validateProps(that.defaultProps);\n      that.props = props;\n   },\n   validate(value, name) {\n      assert.equal(typeof name, 'string', 'name');\n      var meta = that.props[name];\n      if (meta) {\n         that.validateMeta(meta, value, name);\n      }\n      return value;\n   },\n   validateMeta(meta, value, name) {\n      if (value === undefined) {\n         if (!meta.optional) {\n            throw new Error(`missing ${name}`);\n         }\n      }\n      if (meta.min) {\n         if (value >= meta.min) {\n         } else {\n            throw new Error(`${name} (${value}) min ${meta.min}`);\n         }\n      }\n      if (meta.max) {\n         if (value > meta.max) {\n            throw new Error(`${name} (${value}) max ${meta.max}`);\n         }\n      }\n      return value;\n   },\n   addTimestampInterval(timestamp, interval, name) {\n      if (!interval || interval < that.minInterval || interval > that.maxInterval) {\n         throw new Error(`${name} (${interval}) interval`);\n      }\n      return that.parseTimestamp(timestamp, name) + that.parseInt(interval);\n   },\n   validateTimestamp(value, name) {\n      var timestamp = that.parseTimestamp(value, name);\n      if (!timestamp) {\n         throw new Error(`${name} timestamp`);\n      }\n      return timestamp;\n   },\n   validateMinExclusive(value, min, name) {\n      if (value > min) {\n         return value;\n      } else {\n         throw new Error(`${name} (${value}) min ${min}`);\n      }\n   },\n   validateRangeInclusive(value, range, name) {\n      if (value >= range[0] && value <= range[1]) {\n         return value;\n      } else {\n         throw new Error(`${name} (${value}) range ${range}`);\n      }\n   },\n   parseTimestamp(value, name) {\n      var timestamp = that.parseInt(value, name);\n      if (timestamp > 0 && timestamp < that.minTimestamp) {\n         throw new Error(`${name} (${value}) timestamp`);\n      }\n      return timestamp;\n   },\n   parseInt(value, name) {\n      if (value === 0) {\n         return 0;\n      } else if (!value) {\n         return undefined;\n      }\n      var integerValue = parseInt(value);\n      if (typeof value === 'string') {\n      } else if (value !== integerValue) {\n         throw new Error(`${name} (${value}) parseInt type ${typeof value}`);\n      }\n      if (integerValue === NaN) {\n         throw new Error(`${name} (${value}) parseInt NaN`);\n      }\n      return integerValue;\n   },\n   validateInteger(value, name) {\n      return that.validate(value, name);\n   },\n   validateIntegerMin(value, min, name) {\n      that.validate(value, name);\n      if (value >= min) {\n      } else {\n         throw new Error(`${name} (${value}) min ${min}`);\n      }\n      return value;\n   },\n   validateIntegerMin(value, min, name) {\n      that.validate(value, name);\n      if (value >= min) {\n      } else {\n         throw new Error(`${name} (${value}) min ${min}`);\n      }\n      return value;\n   }\n\n};\n*/\n"]}